package test_fixtures

// Autogenerated by github.com/wendigo/go-bind-plugin on 2016-11-08 14:50:02.091219221 +0100 CET, do not edit!
// Command: /var/folders/43/1y0rrqr55zq3f8cj5wpkt1kmhc7r33/T/go-build394996989/github.com/wendigo/go-bind-plugin/_test/go-bind-plugin.test -test.v=true
//
// Plugin ./plugin.so info:
// - package: github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin
// - size: 2124628 bytes
// - sha256: 8135d0494cdc688e053bb92d23406724106fe884a656b8b21373e5e44eff0e38

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	http_1 "github.com/wendigo/plugin_test/plug/http"
	"io"
	"net/http"
	"os"
	"plugin"
	"reflect"
	"strings"
)

// PluginWrapper wraps symbols (functions and variables) exported by plugin github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin
//
// See docs at https://godoc.org/github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin
type PluginWrapper struct {
	// Exported functions
	_DoWorkOnChan2          func(<-chan http_1.Work) chan<- http.Header
	_DoWorkMap              func(map[string]*http_1.Work) *http_1.Work
	_PrintHello2            func(int) string
	_DoWorkOnChan           func(<-chan int) chan<- int32
	_DoWorkingString        func(string) http_1.Work
	_DoWorkIntArray         func(map[string]int) [5]int32
	_DoWork2                func(http.Header, http.Header) string
	_DoWorkArray            func([]*http_1.Work) http_1.Work
	_PrintHello             func() string
	_DoWorkInt              func(map[string]int) []int32
	_DoWork4                func() http.Header
	_DoWorkIntArrayVariadic func(...map[string]int) [5]int32
	_DoWork3                func() *http.Header
	_DoWork                 func(*http.Header) *http.Header

	// Exported variables (public references)

	// See docs at https://godoc.org/github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin#V
	V *func(http.Header, http.Header) string
	// See docs at https://godoc.org/github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin#Y
	Y **http.Header
	// See docs at https://godoc.org/github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin#Z
	Z *func() http.Header
	// See docs at https://godoc.org/github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin#X
	X *http.Header
}

// DoWorkOnChan2 function was exported from plugin github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin symbol 'DoWorkOnChan2'
//
// See docs at https://godoc.org/github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin#DoWorkOnChan2
func (p *PluginWrapper) DoWorkOnChan2(in0 <-chan http_1.Work) chan<- http.Header {
	return p._DoWorkOnChan2(in0)
}

// DoWorkMap function was exported from plugin github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin symbol 'DoWorkMap'
//
// See docs at https://godoc.org/github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin#DoWorkMap
func (p *PluginWrapper) DoWorkMap(in0 map[string]*http_1.Work) *http_1.Work {
	return p._DoWorkMap(in0)
}

// PrintHello2 function was exported from plugin github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin symbol 'PrintHello2'
//
// See docs at https://godoc.org/github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin#PrintHello2
func (p *PluginWrapper) PrintHello2(in0 int) string {
	return p._PrintHello2(in0)
}

// DoWorkOnChan function was exported from plugin github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin symbol 'DoWorkOnChan'
//
// See docs at https://godoc.org/github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin#DoWorkOnChan
func (p *PluginWrapper) DoWorkOnChan(in0 <-chan int) chan<- int32 {
	return p._DoWorkOnChan(in0)
}

// DoWorkingString function was exported from plugin github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin symbol 'DoWorkingString'
//
// See docs at https://godoc.org/github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin#DoWorkingString
func (p *PluginWrapper) DoWorkingString(in0 string) http_1.Work {
	return p._DoWorkingString(in0)
}

// DoWorkIntArray function was exported from plugin github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin symbol 'DoWorkIntArray'
//
// See docs at https://godoc.org/github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin#DoWorkIntArray
func (p *PluginWrapper) DoWorkIntArray(in0 map[string]int) [5]int32 {
	return p._DoWorkIntArray(in0)
}

// DoWork2 function was exported from plugin github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin symbol 'DoWork2'
//
// See docs at https://godoc.org/github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin#DoWork2
func (p *PluginWrapper) DoWork2(in0 http.Header, in1 http.Header) string {
	return p._DoWork2(in0, in1)
}

// DoWorkArray function was exported from plugin github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin symbol 'DoWorkArray'
//
// See docs at https://godoc.org/github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin#DoWorkArray
func (p *PluginWrapper) DoWorkArray(in0 []*http_1.Work) http_1.Work {
	return p._DoWorkArray(in0)
}

// PrintHello function was exported from plugin github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin symbol 'PrintHello'
//
// See docs at https://godoc.org/github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin#PrintHello
func (p *PluginWrapper) PrintHello() string {
	return p._PrintHello()
}

// DoWorkInt function was exported from plugin github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin symbol 'DoWorkInt'
//
// See docs at https://godoc.org/github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin#DoWorkInt
func (p *PluginWrapper) DoWorkInt(in0 map[string]int) []int32 {
	return p._DoWorkInt(in0)
}

// DoWork4 function was exported from plugin github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin symbol 'DoWork4'
//
// See docs at https://godoc.org/github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin#DoWork4
func (p *PluginWrapper) DoWork4() http.Header {
	return p._DoWork4()
}

// DoWorkIntArrayVariadic function was exported from plugin github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin symbol 'DoWorkIntArrayVariadic'
//
// See docs at https://godoc.org/github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin#DoWorkIntArrayVariadic
func (p *PluginWrapper) DoWorkIntArrayVariadic(in0 ...map[string]int) [5]int32 {
	return p._DoWorkIntArrayVariadic(in0...)
}

// DoWork3 function was exported from plugin github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin symbol 'DoWork3'
//
// See docs at https://godoc.org/github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin#DoWork3
func (p *PluginWrapper) DoWork3() *http.Header {
	return p._DoWork3()
}

// DoWork function was exported from plugin github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin symbol 'DoWork'
//
// See docs at https://godoc.org/github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin#DoWork
func (p *PluginWrapper) DoWork(in0 *http.Header) *http.Header {
	return p._DoWork(in0)
}

// String returnes textual representation of the wrapper. It provides info on exported symbols and variables.
func (p *PluginWrapper) String() string {
	var lines []string
	lines = append(lines, "Wrapper info:")
	lines = append(lines, "\t- Generated on: 2016-11-08 14:50:02.091219221 +0100 CET")
	lines = append(lines, "\t- Command: /var/folders/43/1y0rrqr55zq3f8cj5wpkt1kmhc7r33/T/go-build394996989/github.com/wendigo/go-bind-plugin/_test/go-bind-plugin.test -test.v=true")
	lines = append(lines, "Plugin info:")
	lines = append(lines, "\t- package: github.com/wendigo/go-bind-plugin/internal/test_fixtures/complex_plugin")
	lines = append(lines, "\t- sha256 sum: 8135d0494cdc688e053bb92d23406724106fe884a656b8b21373e5e44eff0e38")
	lines = append(lines, "\t- size: 2124628 bytes")
	lines = append(lines, "Exported functions")
	lines = append(lines, "\t- DoWorkOnChan2 func(<-chan http_1.Work) (chan<- http.Header)")
	lines = append(lines, "\t- DoWorkMap func(map[string]*http_1.Work) (*http_1.Work)")
	lines = append(lines, "\t- PrintHello2 func(int) (string)")
	lines = append(lines, "\t- DoWorkOnChan func(<-chan int) (chan<- int32)")
	lines = append(lines, "\t- DoWorkingString func(string) (http_1.Work)")
	lines = append(lines, "\t- DoWorkIntArray func(map[string]int) ([5]int32)")
	lines = append(lines, "\t- DoWork2 func(http.Header, http.Header) (string)")
	lines = append(lines, "\t- DoWorkArray func([]*http_1.Work) (http_1.Work)")
	lines = append(lines, "\t- PrintHello func() (string)")
	lines = append(lines, "\t- DoWorkInt func(map[string]int) ([]int32)")
	lines = append(lines, "\t- DoWork4 func() (http.Header)")
	lines = append(lines, "\t- DoWorkIntArrayVariadic func(...map[string]int) ([5]int32)")
	lines = append(lines, "\t- DoWork3 func() (*http.Header)")
	lines = append(lines, "\t- DoWork func(*http.Header) (*http.Header)")

	lines = append(lines, "Exported variables:")
	lines = append(lines, "\t- V func(http.Header, http.Header) (string)")
	lines = append(lines, "\t- Y *http.Header")
	lines = append(lines, "\t- Z func() (http.Header)")
	lines = append(lines, "\t- X http.Header")

	lines = append(lines, "Plugin imports:")
	lines = append(lines, "\t- github.com/wendigo/plugin_test/plug/http as http_1")

	return strings.Join(lines, "\n")
}

// LoadPluginWrapper loads plugin from the given path and binds symbols (variables and functions)
// to the PluginWrapper struct.
// When plugin is loaded sha256 checksum is computed and checked against precomputed once. On mismatch error is returned.
func LoadPluginWrapper(path string) (*PluginWrapper, error) {
	p, err := plugin.Open(path)

	if err != nil {
		return nil, fmt.Errorf("Could not open plugin: %s", err)
	}

	fileChecksum := func(path string) (string, error) {
		hasher := sha256.New()

		file, err := os.Open(path)

		if err != nil {
			return "", err
		}
		defer file.Close()

		if _, err := io.Copy(hasher, file); err != nil {
			return "", err
		}

		return hex.EncodeToString(hasher.Sum(nil)), nil
	}

	checksum, err := fileChecksum(path)
	if err != nil {
		return nil, fmt.Errorf("Could not calculate file %s checksum", path)
	}

	if checksum != "8135d0494cdc688e053bb92d23406724106fe884a656b8b21373e5e44eff0e38" {
		return nil, fmt.Errorf("Sha256 checksum mismatch (expected: 8135d0494cdc688e053bb92d23406724106fe884a656b8b21373e5e44eff0e38, actual: %s)", checksum)
	}

	ret := new(PluginWrapper)

	funcDoWorkOnChan2, err := p.Lookup("DoWorkOnChan2")
	if err != nil {
		return nil, err
	}

	if typed, ok := funcDoWorkOnChan2.(func(<-chan http_1.Work) chan<- http.Header); ok {
		ret._DoWorkOnChan2 = typed
	} else {
		return nil, fmt.Errorf("Could not export function 'DoWorkOnChan2', incompatible types 'func(<-chan http_1.Work) (chan<- http.Header)' and '%s'", reflect.TypeOf(funcDoWorkOnChan2))
	}

	funcDoWorkMap, err := p.Lookup("DoWorkMap")
	if err != nil {
		return nil, err
	}

	if typed, ok := funcDoWorkMap.(func(map[string]*http_1.Work) *http_1.Work); ok {
		ret._DoWorkMap = typed
	} else {
		return nil, fmt.Errorf("Could not export function 'DoWorkMap', incompatible types 'func(map[string]*http_1.Work) (*http_1.Work)' and '%s'", reflect.TypeOf(funcDoWorkMap))
	}

	funcPrintHello2, err := p.Lookup("PrintHello2")
	if err != nil {
		return nil, err
	}

	if typed, ok := funcPrintHello2.(func(int) string); ok {
		ret._PrintHello2 = typed
	} else {
		return nil, fmt.Errorf("Could not export function 'PrintHello2', incompatible types 'func(int) (string)' and '%s'", reflect.TypeOf(funcPrintHello2))
	}

	funcDoWorkOnChan, err := p.Lookup("DoWorkOnChan")
	if err != nil {
		return nil, err
	}

	if typed, ok := funcDoWorkOnChan.(func(<-chan int) chan<- int32); ok {
		ret._DoWorkOnChan = typed
	} else {
		return nil, fmt.Errorf("Could not export function 'DoWorkOnChan', incompatible types 'func(<-chan int) (chan<- int32)' and '%s'", reflect.TypeOf(funcDoWorkOnChan))
	}

	funcDoWorkingString, err := p.Lookup("DoWorkingString")
	if err != nil {
		return nil, err
	}

	if typed, ok := funcDoWorkingString.(func(string) http_1.Work); ok {
		ret._DoWorkingString = typed
	} else {
		return nil, fmt.Errorf("Could not export function 'DoWorkingString', incompatible types 'func(string) (http_1.Work)' and '%s'", reflect.TypeOf(funcDoWorkingString))
	}

	funcDoWorkIntArray, err := p.Lookup("DoWorkIntArray")
	if err != nil {
		return nil, err
	}

	if typed, ok := funcDoWorkIntArray.(func(map[string]int) [5]int32); ok {
		ret._DoWorkIntArray = typed
	} else {
		return nil, fmt.Errorf("Could not export function 'DoWorkIntArray', incompatible types 'func(map[string]int) ([5]int32)' and '%s'", reflect.TypeOf(funcDoWorkIntArray))
	}

	funcDoWork2, err := p.Lookup("DoWork2")
	if err != nil {
		return nil, err
	}

	if typed, ok := funcDoWork2.(func(http.Header, http.Header) string); ok {
		ret._DoWork2 = typed
	} else {
		return nil, fmt.Errorf("Could not export function 'DoWork2', incompatible types 'func(http.Header, http.Header) (string)' and '%s'", reflect.TypeOf(funcDoWork2))
	}

	funcDoWorkArray, err := p.Lookup("DoWorkArray")
	if err != nil {
		return nil, err
	}

	if typed, ok := funcDoWorkArray.(func([]*http_1.Work) http_1.Work); ok {
		ret._DoWorkArray = typed
	} else {
		return nil, fmt.Errorf("Could not export function 'DoWorkArray', incompatible types 'func([]*http_1.Work) (http_1.Work)' and '%s'", reflect.TypeOf(funcDoWorkArray))
	}

	funcPrintHello, err := p.Lookup("PrintHello")
	if err != nil {
		return nil, err
	}

	if typed, ok := funcPrintHello.(func() string); ok {
		ret._PrintHello = typed
	} else {
		return nil, fmt.Errorf("Could not export function 'PrintHello', incompatible types 'func() (string)' and '%s'", reflect.TypeOf(funcPrintHello))
	}

	funcDoWorkInt, err := p.Lookup("DoWorkInt")
	if err != nil {
		return nil, err
	}

	if typed, ok := funcDoWorkInt.(func(map[string]int) []int32); ok {
		ret._DoWorkInt = typed
	} else {
		return nil, fmt.Errorf("Could not export function 'DoWorkInt', incompatible types 'func(map[string]int) ([]int32)' and '%s'", reflect.TypeOf(funcDoWorkInt))
	}

	funcDoWork4, err := p.Lookup("DoWork4")
	if err != nil {
		return nil, err
	}

	if typed, ok := funcDoWork4.(func() http.Header); ok {
		ret._DoWork4 = typed
	} else {
		return nil, fmt.Errorf("Could not export function 'DoWork4', incompatible types 'func() (http.Header)' and '%s'", reflect.TypeOf(funcDoWork4))
	}

	funcDoWorkIntArrayVariadic, err := p.Lookup("DoWorkIntArrayVariadic")
	if err != nil {
		return nil, err
	}

	if typed, ok := funcDoWorkIntArrayVariadic.(func(...map[string]int) [5]int32); ok {
		ret._DoWorkIntArrayVariadic = typed
	} else {
		return nil, fmt.Errorf("Could not export function 'DoWorkIntArrayVariadic', incompatible types 'func(...map[string]int) ([5]int32)' and '%s'", reflect.TypeOf(funcDoWorkIntArrayVariadic))
	}

	funcDoWork3, err := p.Lookup("DoWork3")
	if err != nil {
		return nil, err
	}

	if typed, ok := funcDoWork3.(func() *http.Header); ok {
		ret._DoWork3 = typed
	} else {
		return nil, fmt.Errorf("Could not export function 'DoWork3', incompatible types 'func() (*http.Header)' and '%s'", reflect.TypeOf(funcDoWork3))
	}

	funcDoWork, err := p.Lookup("DoWork")
	if err != nil {
		return nil, err
	}

	if typed, ok := funcDoWork.(func(*http.Header) *http.Header); ok {
		ret._DoWork = typed
	} else {
		return nil, fmt.Errorf("Could not export function 'DoWork', incompatible types 'func(*http.Header) (*http.Header)' and '%s'", reflect.TypeOf(funcDoWork))
	}

	varV, err := p.Lookup("V")
	if err != nil {
		return nil, err
	}

	if typed, ok := varV.(*func(http.Header, http.Header) string); ok {
		ret.V = typed
	} else {
		return nil, fmt.Errorf("Could not export variable 'V', incompatible types 'func(http.Header, http.Header) (string)' and '%s'", reflect.TypeOf(varV))
	}

	varY, err := p.Lookup("Y")
	if err != nil {
		return nil, err
	}

	if typed, ok := varY.(**http.Header); ok {
		ret.Y = typed
	} else {
		return nil, fmt.Errorf("Could not export variable 'Y', incompatible types '*http.Header' and '%s'", reflect.TypeOf(varY))
	}

	varZ, err := p.Lookup("Z")
	if err != nil {
		return nil, err
	}

	if typed, ok := varZ.(*func() http.Header); ok {
		ret.Z = typed
	} else {
		return nil, fmt.Errorf("Could not export variable 'Z', incompatible types 'func() (http.Header)' and '%s'", reflect.TypeOf(varZ))
	}

	varX, err := p.Lookup("X")
	if err != nil {
		return nil, err
	}

	if typed, ok := varX.(*http.Header); ok {
		ret.X = typed
	} else {
		return nil, fmt.Errorf("Could not export variable 'X', incompatible types 'http.Header' and '%s'", reflect.TypeOf(varX))
	}

	return ret, nil
}
