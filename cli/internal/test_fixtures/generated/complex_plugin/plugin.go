package main

// Autogenerated by github.com/wendigo/go-bind-plugin on 2016-11-12 19:45:33.646987057 +0100 CET, do not edit!
// Command: go-bind-plugin -plugin-path ./internal/test_fixtures/generated/complex_plugin/plugin.so -plugin-package ./internal/test_fixtures/complex_plugin -output-name TestWrapper -output-path ./internal/test_fixtures/generated/complex_plugin/plugin.go -output-package main -sha256 -rebuild
//
// Plugin ./internal/test_fixtures/generated/complex_plugin/plugin.so info:
// - package: github.com/wendigo/go-bind-plugin/cli/internal/test_fixtures/complex_plugin
// - size: 2480028 bytes
// - sha256: 133f74c0be977967a18b417dcabf42954806107513af7ee980cdec7f2e54c889

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"github.com/wendigo/go-bind-plugin/cli/internal/test_fixtures/complex_plugin/http"
	"io"
	"os"
	"plugin"
	"reflect"
	"strings"
)

// TestWrapper wraps symbols (functions and variables) exported by plugin github.com/wendigo/go-bind-plugin/cli/internal/test_fixtures/complex_plugin
//
// See docs at https://godoc.org/github.com/wendigo/go-bind-plugin/cli/internal/test_fixtures/complex_plugin
type TestWrapper struct {
	// Exported functions
	_DoWorkArray            func([]*http.Work) http.Work
	_DoWorkInt              func(map[string]int) []int32
	_DoWorkIntArray         func(map[string]int) [5]int32
	_DoWorkIntArrayVariadic func(...map[string]int) [5]int32
	_DoWorkMap              func(map[string]*http.Work) *http.Work
	_DoWorkOnChan           func(<-chan int) chan<- int32
	_DoWorkOnChan2          func(<-chan http.Work) chan<- http.Work
	_DoWorkingString        func(string) http.Work
	_PrintHello             func() string
	_PrintHello2            func(int) string

	// Exported variables (public references)

	// See docs at https://godoc.org/github.com/wendigo/go-bind-plugin/cli/internal/test_fixtures/complex_plugin#X
	X *http.Work
	// See docs at https://godoc.org/github.com/wendigo/go-bind-plugin/cli/internal/test_fixtures/complex_plugin#Y
	Y **http.Work
}

// DoWorkArray function was exported from plugin github.com/wendigo/go-bind-plugin/cli/internal/test_fixtures/complex_plugin symbol 'DoWorkArray'
//
// See docs at https://godoc.org/github.com/wendigo/go-bind-plugin/cli/internal/test_fixtures/complex_plugin#DoWorkArray
func (p *TestWrapper) DoWorkArray(in0 []*http.Work) http.Work {
	return p._DoWorkArray(in0)
}

// DoWorkInt function was exported from plugin github.com/wendigo/go-bind-plugin/cli/internal/test_fixtures/complex_plugin symbol 'DoWorkInt'
//
// See docs at https://godoc.org/github.com/wendigo/go-bind-plugin/cli/internal/test_fixtures/complex_plugin#DoWorkInt
func (p *TestWrapper) DoWorkInt(in0 map[string]int) []int32 {
	return p._DoWorkInt(in0)
}

// DoWorkIntArray function was exported from plugin github.com/wendigo/go-bind-plugin/cli/internal/test_fixtures/complex_plugin symbol 'DoWorkIntArray'
//
// See docs at https://godoc.org/github.com/wendigo/go-bind-plugin/cli/internal/test_fixtures/complex_plugin#DoWorkIntArray
func (p *TestWrapper) DoWorkIntArray(in0 map[string]int) [5]int32 {
	return p._DoWorkIntArray(in0)
}

// DoWorkIntArrayVariadic function was exported from plugin github.com/wendigo/go-bind-plugin/cli/internal/test_fixtures/complex_plugin symbol 'DoWorkIntArrayVariadic'
//
// See docs at https://godoc.org/github.com/wendigo/go-bind-plugin/cli/internal/test_fixtures/complex_plugin#DoWorkIntArrayVariadic
func (p *TestWrapper) DoWorkIntArrayVariadic(in0 ...map[string]int) [5]int32 {
	return p._DoWorkIntArrayVariadic(in0...)
}

// DoWorkMap function was exported from plugin github.com/wendigo/go-bind-plugin/cli/internal/test_fixtures/complex_plugin symbol 'DoWorkMap'
//
// See docs at https://godoc.org/github.com/wendigo/go-bind-plugin/cli/internal/test_fixtures/complex_plugin#DoWorkMap
func (p *TestWrapper) DoWorkMap(in0 map[string]*http.Work) *http.Work {
	return p._DoWorkMap(in0)
}

// DoWorkOnChan function was exported from plugin github.com/wendigo/go-bind-plugin/cli/internal/test_fixtures/complex_plugin symbol 'DoWorkOnChan'
//
// See docs at https://godoc.org/github.com/wendigo/go-bind-plugin/cli/internal/test_fixtures/complex_plugin#DoWorkOnChan
func (p *TestWrapper) DoWorkOnChan(in0 <-chan int) chan<- int32 {
	return p._DoWorkOnChan(in0)
}

// DoWorkOnChan2 function was exported from plugin github.com/wendigo/go-bind-plugin/cli/internal/test_fixtures/complex_plugin symbol 'DoWorkOnChan2'
//
// See docs at https://godoc.org/github.com/wendigo/go-bind-plugin/cli/internal/test_fixtures/complex_plugin#DoWorkOnChan2
func (p *TestWrapper) DoWorkOnChan2(in0 <-chan http.Work) chan<- http.Work {
	return p._DoWorkOnChan2(in0)
}

// DoWorkingString function was exported from plugin github.com/wendigo/go-bind-plugin/cli/internal/test_fixtures/complex_plugin symbol 'DoWorkingString'
//
// See docs at https://godoc.org/github.com/wendigo/go-bind-plugin/cli/internal/test_fixtures/complex_plugin#DoWorkingString
func (p *TestWrapper) DoWorkingString(in0 string) http.Work {
	return p._DoWorkingString(in0)
}

// PrintHello function was exported from plugin github.com/wendigo/go-bind-plugin/cli/internal/test_fixtures/complex_plugin symbol 'PrintHello'
//
// See docs at https://godoc.org/github.com/wendigo/go-bind-plugin/cli/internal/test_fixtures/complex_plugin#PrintHello
func (p *TestWrapper) PrintHello() string {
	return p._PrintHello()
}

// PrintHello2 function was exported from plugin github.com/wendigo/go-bind-plugin/cli/internal/test_fixtures/complex_plugin symbol 'PrintHello2'
//
// See docs at https://godoc.org/github.com/wendigo/go-bind-plugin/cli/internal/test_fixtures/complex_plugin#PrintHello2
func (p *TestWrapper) PrintHello2(in0 int) string {
	return p._PrintHello2(in0)
}

// String returnes textual representation of the wrapper. It provides info on exported symbols and variables.
func (p *TestWrapper) String() string {
	var lines []string
	lines = append(lines, "Struct TestWrapper:")
	lines = append(lines, "\t- Generated on: 2016-11-12 19:45:33.646987057 +0100 CET")
	lines = append(lines, "\t- Command: go-bind-plugin -plugin-path ./internal/test_fixtures/generated/complex_plugin/plugin.so -plugin-package ./internal/test_fixtures/complex_plugin -output-name TestWrapper -output-path ./internal/test_fixtures/generated/complex_plugin/plugin.go -output-package main -sha256 -rebuild")
	lines = append(lines, "\nPlugin info:")
	lines = append(lines, "\t- package: github.com/wendigo/go-bind-plugin/cli/internal/test_fixtures/complex_plugin")
	lines = append(lines, "\t- sha256 sum: 133f74c0be977967a18b417dcabf42954806107513af7ee980cdec7f2e54c889")
	lines = append(lines, "\t- size: 2480028 bytes")
	lines = append(lines, "\nExported functions (10):")
	lines = append(lines, "\t- DoWorkArray func([]*http.Work) (http.Work)")
	lines = append(lines, "\t- DoWorkInt func(map[string]int) ([]int32)")
	lines = append(lines, "\t- DoWorkIntArray func(map[string]int) ([5]int32)")
	lines = append(lines, "\t- DoWorkIntArrayVariadic func(...map[string]int) ([5]int32)")
	lines = append(lines, "\t- DoWorkMap func(map[string]*http.Work) (*http.Work)")
	lines = append(lines, "\t- DoWorkOnChan func(<-chan int) (chan<- int32)")
	lines = append(lines, "\t- DoWorkOnChan2 func(<-chan http.Work) (chan<- http.Work)")
	lines = append(lines, "\t- DoWorkingString func(string) (http.Work)")
	lines = append(lines, "\t- PrintHello func() (string)")
	lines = append(lines, "\t- PrintHello2 func(int) (string)")

	lines = append(lines, "\nExported variables (2):")
	lines = append(lines, "\t- X http.Work")
	lines = append(lines, "\t- Y *http.Work")

	return strings.Join(lines, "\n")
}

// BindTestWrapper loads plugin from the given path and binds symbols (variables and functions)
// to the TestWrapper struct.
// When plugin is loaded sha256 checksum is computed and checked against precomputed once. On mismatch error is returned.
func BindTestWrapper(path string) (*TestWrapper, error) {
	p, err := plugin.Open(path)

	if err != nil {
		return nil, fmt.Errorf("could not open plugin: %s", err)
	}

	fileChecksum := func(path string) (string, error) {
		hasher := sha256.New()

		file, err := os.Open(path)

		if err != nil {
			return "", err
		}
		defer file.Close()

		if _, err := io.Copy(hasher, file); err != nil {
			return "", err
		}

		return hex.EncodeToString(hasher.Sum(nil)), nil
	}

	checksum, err := fileChecksum(path)
	if err != nil {
		return nil, fmt.Errorf("could not calculate file %s checksum", path)
	}

	if checksum != "133f74c0be977967a18b417dcabf42954806107513af7ee980cdec7f2e54c889" {
		return nil, fmt.Errorf("SHA256 checksum mismatch (expected: 133f74c0be977967a18b417dcabf42954806107513af7ee980cdec7f2e54c889, actual: %s)", checksum)
	}

	ret := new(TestWrapper)

	funcDoWorkArray, err := p.Lookup("DoWorkArray")
	if err != nil {
		return nil, fmt.Errorf("could not import function 'DoWorkArray', symbol not found: %s", err)
	}

	if typed, ok := funcDoWorkArray.(func([]*http.Work) http.Work); ok {
		ret._DoWorkArray = typed
	} else {
		return nil, fmt.Errorf("could not import function 'DoWorkArray', incompatible types 'func([]*http.Work) (http.Work)' and '%s'", reflect.TypeOf(funcDoWorkArray))
	}

	funcDoWorkInt, err := p.Lookup("DoWorkInt")
	if err != nil {
		return nil, fmt.Errorf("could not import function 'DoWorkInt', symbol not found: %s", err)
	}

	if typed, ok := funcDoWorkInt.(func(map[string]int) []int32); ok {
		ret._DoWorkInt = typed
	} else {
		return nil, fmt.Errorf("could not import function 'DoWorkInt', incompatible types 'func(map[string]int) ([]int32)' and '%s'", reflect.TypeOf(funcDoWorkInt))
	}

	funcDoWorkIntArray, err := p.Lookup("DoWorkIntArray")
	if err != nil {
		return nil, fmt.Errorf("could not import function 'DoWorkIntArray', symbol not found: %s", err)
	}

	if typed, ok := funcDoWorkIntArray.(func(map[string]int) [5]int32); ok {
		ret._DoWorkIntArray = typed
	} else {
		return nil, fmt.Errorf("could not import function 'DoWorkIntArray', incompatible types 'func(map[string]int) ([5]int32)' and '%s'", reflect.TypeOf(funcDoWorkIntArray))
	}

	funcDoWorkIntArrayVariadic, err := p.Lookup("DoWorkIntArrayVariadic")
	if err != nil {
		return nil, fmt.Errorf("could not import function 'DoWorkIntArrayVariadic', symbol not found: %s", err)
	}

	if typed, ok := funcDoWorkIntArrayVariadic.(func(...map[string]int) [5]int32); ok {
		ret._DoWorkIntArrayVariadic = typed
	} else {
		return nil, fmt.Errorf("could not import function 'DoWorkIntArrayVariadic', incompatible types 'func(...map[string]int) ([5]int32)' and '%s'", reflect.TypeOf(funcDoWorkIntArrayVariadic))
	}

	funcDoWorkMap, err := p.Lookup("DoWorkMap")
	if err != nil {
		return nil, fmt.Errorf("could not import function 'DoWorkMap', symbol not found: %s", err)
	}

	if typed, ok := funcDoWorkMap.(func(map[string]*http.Work) *http.Work); ok {
		ret._DoWorkMap = typed
	} else {
		return nil, fmt.Errorf("could not import function 'DoWorkMap', incompatible types 'func(map[string]*http.Work) (*http.Work)' and '%s'", reflect.TypeOf(funcDoWorkMap))
	}

	funcDoWorkOnChan, err := p.Lookup("DoWorkOnChan")
	if err != nil {
		return nil, fmt.Errorf("could not import function 'DoWorkOnChan', symbol not found: %s", err)
	}

	if typed, ok := funcDoWorkOnChan.(func(<-chan int) chan<- int32); ok {
		ret._DoWorkOnChan = typed
	} else {
		return nil, fmt.Errorf("could not import function 'DoWorkOnChan', incompatible types 'func(<-chan int) (chan<- int32)' and '%s'", reflect.TypeOf(funcDoWorkOnChan))
	}

	funcDoWorkOnChan2, err := p.Lookup("DoWorkOnChan2")
	if err != nil {
		return nil, fmt.Errorf("could not import function 'DoWorkOnChan2', symbol not found: %s", err)
	}

	if typed, ok := funcDoWorkOnChan2.(func(<-chan http.Work) chan<- http.Work); ok {
		ret._DoWorkOnChan2 = typed
	} else {
		return nil, fmt.Errorf("could not import function 'DoWorkOnChan2', incompatible types 'func(<-chan http.Work) (chan<- http.Work)' and '%s'", reflect.TypeOf(funcDoWorkOnChan2))
	}

	funcDoWorkingString, err := p.Lookup("DoWorkingString")
	if err != nil {
		return nil, fmt.Errorf("could not import function 'DoWorkingString', symbol not found: %s", err)
	}

	if typed, ok := funcDoWorkingString.(func(string) http.Work); ok {
		ret._DoWorkingString = typed
	} else {
		return nil, fmt.Errorf("could not import function 'DoWorkingString', incompatible types 'func(string) (http.Work)' and '%s'", reflect.TypeOf(funcDoWorkingString))
	}

	funcPrintHello, err := p.Lookup("PrintHello")
	if err != nil {
		return nil, fmt.Errorf("could not import function 'PrintHello', symbol not found: %s", err)
	}

	if typed, ok := funcPrintHello.(func() string); ok {
		ret._PrintHello = typed
	} else {
		return nil, fmt.Errorf("could not import function 'PrintHello', incompatible types 'func() (string)' and '%s'", reflect.TypeOf(funcPrintHello))
	}

	funcPrintHello2, err := p.Lookup("PrintHello2")
	if err != nil {
		return nil, fmt.Errorf("could not import function 'PrintHello2', symbol not found: %s", err)
	}

	if typed, ok := funcPrintHello2.(func(int) string); ok {
		ret._PrintHello2 = typed
	} else {
		return nil, fmt.Errorf("could not import function 'PrintHello2', incompatible types 'func(int) (string)' and '%s'", reflect.TypeOf(funcPrintHello2))
	}

	varX, err := p.Lookup("X")
	if err != nil {
		return nil, fmt.Errorf("could not import variable 'X', symbol not found: %s", err)
	}

	if typed, ok := varX.(*http.Work); ok {
		ret.X = typed
	} else {
		return nil, fmt.Errorf("could not import variable 'X', incompatible types 'http.Work' and '%s'", reflect.TypeOf(varX))
	}

	varY, err := p.Lookup("Y")
	if err != nil {
		return nil, fmt.Errorf("could not import variable 'Y', symbol not found: %s", err)
	}

	if typed, ok := varY.(**http.Work); ok {
		ret.Y = typed
	} else {
		return nil, fmt.Errorf("could not import variable 'Y', incompatible types '*http.Work' and '%s'", reflect.TypeOf(varY))
	}

	return ret, nil
}


func main() {
  pl, err := BindTestWrapper("./internal/test_fixtures/generated/complex_plugin/plugin.so")

  if err != nil {
    fmt.Println(err)
    os.Exit(1)
  }

  fmt.Println(pl)
}
