package cli

var generateFileTemplate = `package {{.OutputPackage}}
// Autogenerated by github.com/wendigo/go-bind-plugin on {{.Build.Date}}, do not edit!
// Command: {{.Build.Command}}
//
// Plugin {{.Config.PluginPath}} info:
// - package: {{.Plugin.Package}}
// - size: {{.Plugin.Size}} bytes
// - sha256: {{.Plugin.Sha256}}

import ({{ range $key, $val := .Plugin.ImportsNames }}
  {{if isStandardImport $val $key }}"{{ $val }}"{{else}}{{ $key }} "{{ $val }}"{{end }}{{end}}
)
{{$useVarReference := .Config.DereferenceVariables|not}}{{$pluginPackage := .Plugin.Package}}{{$receiver := .Config.OutputName}}
// {{.Config.OutputName}} wraps symbols (functions and variables) exported by plugin {{.Plugin.Package}}
//
// See docs at https://godoc.org/{{$pluginPackage}}
type {{.Config.OutputName}} struct {
  // Exported functions
  {{range .Plugin.Functions}}_{{ .Name }} {{ .Signature }}
  {{end}}
  // Exported variables (public references)
  {{range .Plugin.Variables}}
  // See docs at https://godoc.org/{{$pluginPackage}}#{{ .Name }}
  {{ .Name }} {{if $useVarReference}}*{{end}}{{ .Signature }}{{end}}
}
{{range .Plugin.Functions}}
// {{.Name}} function was exported from plugin {{$pluginPackage}} symbol '{{.Name}}'
//
// See docs at https://godoc.org/{{$pluginPackage}}#{{.Name}}
func (p *{{$receiver}}) {{.Name}}{{.TrimmedSignature}} {
  {{ if .ReturnsVoid | not }}return {{ end }}p._{{ .Name }}({{ .ArgumentsCall }})
}
{{end}}

// String returnes textual representation of the wrapper. It provides info on exported symbols and variables.
func (p *{{$receiver}}) String() string {
  var lines []string
  lines = append(lines, "Wrapper info:")
  lines = append(lines, "\t- Generated on: {{.Build.Date}}")
  lines = append(lines, "\t- Command: {{.Build.Command}}")
  lines = append(lines, "\nPlugin info:")
  lines = append(lines, "\t- package: {{$pluginPackage}}")
  lines = append(lines, "\t- sha256 sum: {{.Plugin.Sha256}}")
  lines = append(lines, "\t- size: {{.Plugin.Size}} bytes")
  lines = append(lines, "\nExported functions ({{.Plugin.Functions|len}}):")
  {{ range .Plugin.Functions }}lines = append(lines, "\t- {{.Name}} {{ .Signature }}")
  {{ end }}
  lines = append(lines, "\nExported variables ({{.Plugin.Variables|len}}):")
  {{ range .Plugin.Variables }}lines = append(lines, "\t- {{.Name}} {{ .Signature }}")
  {{ end }}
  lines = append(lines, "\nPlugin imports:"){{ range $key, $val := .Plugin.ImportsNames }}{{if isStandardImport $val $key | not }}
  lines = append(lines, "\t- {{ $val }} as {{ $key }}")
  {{end}}{{ end }}
  return strings.Join(lines, "\n")
}

// Load{{.Config.OutputName}} loads plugin from the given path and binds symbols (variables and functions)
// to the {{.Config.OutputName}} struct. {{if .Config.DereferenceVariables}}All variables are derefenences. {{end}}
{{ if .Config.CheckSha256 }}// When plugin is loaded sha256 checksum is computed and checked against precomputed once. On mismatch error is returned. {{end}}
func Bind{{.Config.OutputName}}(path string) (*{{.Config.OutputName}}, error) {
    p, err := plugin.Open(path)

    if err != nil {
      return nil, fmt.Errorf("Could not open plugin: %s", err)
    }
    {{ if .Config.CheckSha256 }}
    fileChecksum := func(path string) (string, error) {
    	hasher := sha256.New()

    	file, err := os.Open(path)

    	if err != nil {
    		return "", err
    	}
    	defer file.Close()

    	if _, err := io.Copy(hasher, file); err != nil {
    		return "", err
    	}

    	return hex.EncodeToString(hasher.Sum(nil)), nil
    }

    checksum, err := fileChecksum(path)
    if err != nil {
      return nil, fmt.Errorf("Could not calculate file %s checksum", path)
    }

    if checksum != "{{.Plugin.Sha256}}" {
      return nil, fmt.Errorf("Sha256 checksum mismatch (expected: {{.Plugin.Sha256}}, actual: %s)", checksum)
    }{{ end }}

    ret := new({{.Config.OutputName}})
    {{range .Plugin.Functions}}
    func{{ .Name }}, err := p.Lookup("{{ .Name }}")
    if err != nil {
      return nil, err
    }

    if typed, ok := func{{ .Name }}.({{ .Signature }}); ok {
      ret._{{ .Name }} = typed
    } else {
      return nil, fmt.Errorf("Could not export function '{{ .Name }}', incompatible types '{{ .Signature }}' and '%s'", reflect.TypeOf(func{{ .Name }}))
    }
    {{end}}{{range .Plugin.Variables}}
    var{{ .Name }}, err := p.Lookup("{{ .Name }}")
    if err != nil {
      return nil, err
    }

    if typed, ok := var{{ .Name }}.(*{{.Signature}}); ok {
      ret.{{ .Name }} = {{if $useVarReference|not}}*{{end}}typed
    } else {
      return nil, fmt.Errorf("Could not export variable '{{ .Name }}', incompatible types '{{ .Signature }}' and '%s'", reflect.TypeOf(var{{ .Name }}))
    }
    {{end}}
    return ret, nil
}
`
